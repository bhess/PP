package simulation;

import java.sql.Connection;
import java.util.LinkedList;
import java.util.List;
import java.util.Observer;

import evaluation.OutputAnalysis;

import simulation.data.Configuration;
import simulation.data.ConfigurationSource;
import simulation.entities.Distributor;
import simulation.entities.Manufacturer;
import simulation.entities.Recipient;
import simulation.observer.DBRecorder;
import simulation.observer.Eavesdropper;
import simulation.utilities.DBConnection;
import simulation.utilities.GraphUtilities;
import simulation.utilities.Logging;

/**
 * @author bhess
 * 
 * Objects from this class represent a Supply chain simulation
 *
 */
public class Simulator {

	/**
	 * Initializing a simulation with a configuration, some observers,
	 * the DB table name and the thread number
	 * @param cs
	 * A source for the configuration for this simulation
	 * @param obs
	 * List of observers (e.g. event recorders, console writer...)
	 * @param tableName
	 * Table name of the DB
	 * @param thread
	 * The thread number this simulation should run on
	 */
	public Simulator(ConfigurationSource cs, List<Observer> obs, String tableName, int thread) {
		try {
			config = cs.getConfiguration();
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
		this.thread = thread;
		config.printConfig();
		this.tableName = tableName;
		this.conn = DBConnection.getConnection(thread);
		this.avgTime = 0; //getAvgTime();
		Eavesdropper eave = new Eavesdropper(avgTime, "eaves" + tableName, thread);
		DBRecorder dbr = new DBRecorder(tableName, thread);
		//ConsoleRecorder cr = new ConsoleRecorder();
		for (Manufacturer m : config.manufacturers) {
			m.setSpy(eave);
		}
		for (Recipient r : config.partners) {
			// adds observers
			if (obs != null) {
				for (Observer o : obs) {
					r.addObserver(o);
				}
			}
			r.addObserver(dbr);
			r.addObserver(eave);
			//r.addObserver(cr);
		}
	}
	
	/**
	 * the corresponding configuration
	 */
	public Configuration config;
	
	/**
	 * the corresponding DB connection to record traces
	 */
	Connection conn;

	/**
	 * The thread the simulation runs on
	 */
	private int thread;
	
	/**
	 * The computed average time in the Supply chain configuration
	 * (not empirically, so not exact)
	 */
	private long avgTime;
	
	/**
	 * The DB table name of this simulation
	 */
	private String tableName;
	
	/**
	 * Compute the average time In the supply chain
	 * Using only the SC graph structure
	 * @return
	 */
	public long getAvgTime() {
		GraphUtilities gu = new GraphUtilities(config);
		return gu.getAvgTimeInChain(0);
	}
	
	/**
	 * gets the number of products flowing in this simulation
	 * in total
	 * @return
	 */
	public long getNumberOfProducts() {
		long res = 0;
		for (Manufacturer m : config.manufacturers) {
			res += (long)(((double)m.productionTime / 86400.0d) * (double)m.productionRate); 
		}
		return res;
	}
	
	/**
	 * Starting the simulation
	 */
	public void simulate() {
		int id = 0;
		List<Manufacturer> counterfeiters = new LinkedList<Manufacturer>();
		for (Manufacturer m : config.manufacturers) {
			if (m.reuseID != 0.0f) {
				counterfeiters.add(m);
				continue;
			}
			id = m.produce(id, config.startDate);
			Recipient r;
			while ((r = m.shipProduct()) != null) {
				for (;r instanceof Distributor; r = ((Distributor)r).shipProduct());
			}
		}
		for (Manufacturer m : counterfeiters) {
			id = m.produce(id, config.startDate);
			Recipient r;
			while ((r = m.shipProduct()) != null) {
				for (;r instanceof Distributor; r = ((Distributor)r).shipProduct());
			}
		}
	}
	
	@Deprecated
	public void analyzeOutput() {
		Logging.log.info("--------------------------------------------------");
		Logging.log.info("predicted avg time in SC: " + avgTime + "s");
		Logging.log.info("Output analysis...");
		new OutputAnalysis(tableName, thread).analyzeOutput(true);
	}
	

}
