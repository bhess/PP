package simulation.utilities;
import java.util.BitSet;
import java.util.HashSet;

/**
 * @author bhess
 * Class to list combinations choose(n,k) in a lexicographic way
 * 
 * originally from James McCaffrey 
 * 'Generating the mth Lexicographical Element of a Mathematical Combination'
 * 
 * http://msdn.microsoft.com/en-us/library/aa289166(VS.71).aspx
 */
public class Combination {

	/*
	public static void main(String[] args) throws Exception {

		int originalTraceLength = 30;
		int failes1 = 3, failes2 = 2, failes3 = 2;

		int failed = failes1 + failes2 * 2 + failes3 * 3;
		int combinationK = failes1 + failes2 + failes3;
		int combinationN = originalTraceLength - failed + combinationK;

		long t0 = System.currentTimeMillis();
		int version1 = version1(originalTraceLength, failes1, failes2, failes3,
				failed, combinationK, combinationN);
		long time = (System.currentTimeMillis() - t0) / 1000;
		System.out.println(version1 + " " + time + "s");

		t0 = System.currentTimeMillis();
		int version2 = version2(originalTraceLength, failes1, failes2, failes3,
				failed, combinationK, combinationN);
		time = (System.currentTimeMillis() - t0) / 1000;
		System.out.println(version2 + " " + time + "s");
	}

	static int version1(int originalTraceLength, int failes1, int failes2,
			int failes3, int failed, int combinationK, int combinationN)
			throws Exception {

		HashSet<BitSet> hs = new HashSet<BitSet>();

		for (Combination cc = new Combination(combinationN, combinationK); cc != null; cc = cc
				.Successor()) {
			int[] places = getPlaces(failes1, failes2, failes3);
			do {
				hs.add(cc.toBitSet(places, originalTraceLength));
			} while (Perm.gen_perm_rep_next(places, combinationK) == Perm.GEN_NEXT);
		}
		return hs.size();
	}
	*/

	static int version2(int originalTraceLength, int failes1, int failes2,
			int failes3, int failed, int combinationK, int combinationN)
			throws Exception {

		permutations = new int[factorial(combinationK) + 1][combinationK];
		visit(0);
		// System.out.println(counter);
		int[] places = getPlaces(failes1, failes2, failes3);
		// calculate all permutations
		for (int i = 0; i < permutations.length - 1; ++i) {
			for (int j = 0; j < permutations[i].length; ++j) {
				permutations[i][j] = places[permutations[i][j] - 1];
			}
		}

		HashSet<BitSet> hs = new HashSet<BitSet>();

		for (Combination cc = new Combination(combinationN, combinationK); cc != null; cc = cc
				.Successor()) {

			for (int i = 0; i < permutations.length - 1; ++i) { //
				hs.add(cc.toBitSet(permutations[i], originalTraceLength));
			}

		}
		return hs.size();
	}

	static int[][] permutations;

	static int[] getPlaces(int f1, int f2, int f3) {
		int[] res = new int[f1 + f2 + f3];
		int count = 0;
		for (int i = 0; i < f1; ++i) {
			res[count++] = 1;
		}
		for (int i = 0; i < f2; ++i) {
			res[count++] = 2;
		}
		for (int i = 0; i < f3; ++i) {
			res[count++] = 3;
		}
		return res;
	}

	static void getNext(int[] before, int[] next) {
		for (int i = 0; i < before.length; ++i)
			next[i] = before[i];
		int N = next.length;
		int i = N - 1;

		while (next[i - 1] >= next[i])
			i--;

		int j = N;

		while (next[j - 1] <= next[i - 1])
			j--;

		// swap values at positions (i-1) and (j-1)
		next[i - 1] = before[j - 1];
		next[j - 1] = before[i - 1];

		i++;
		j = N;

		while (i < j) {
			next[i - 1] = before[j - 1];
			next[j - 1] = before[i - 1];
			i++;
			j--;
		}
	}

	static int level = -1, counter = 0;

	static void visit(int k) {
		level++;
		permutations[counter][k] = level; // = is assignment

		if (level == permutations[counter].length) { // == is comparison
			for (int i = 0; i < permutations[counter].length; ++i) {
				permutations[counter + 1][i] = permutations[counter][i];
			}
			// for (int i = 0; i < permutations[counter].length; ++i)
			// System.out.print(permutations[counter][i]); // to the list box
			// System.out.println();
			++counter;
		} else
			for (int i = 0; i < permutations[counter].length; i++)
				if (permutations[counter][i] == 0)
					visit(i);

		level = level - 1;
		permutations[counter][k] = 0;
	}

	public static int factorial(int n) {
		if (n <= 1) // base case
			return 1;
		else
			return n * factorial(n - 1);
	}

	void AddItem() {
		// Form a string from Value[0], Value[1], ... Value[N-1].
		// At this point, this array contains one complete permutation.
		// The string is added to the list box for display.
		// The function, as such, is inessential to the algorithms.
	}

	private long n = 0;
	private long k = 0;
	private long[] data = null;

	public Combination Element(long m) throws Exception {
		long[] ans = new long[(int) this.k];

		long a = this.n;
		long b = this.k;
		long x = (choose(this.n, this.k) - 1) - m; // x is the "dual" of m

		for (long i = 0; i < this.k; ++i) {
			ans[(int) i] = LargestV(a, b, x); // largest value v, where v <
			// a and vCb < x
			x = x - choose(ans[(int) i], b);
			a = ans[(int) i];
			b = b - 1;
		}

		for (long i = 0; i < this.k; ++i) {
			ans[(int) i] = (n - 1) - ans[(int) i];
		}

		return new Combination(this.n, this.k, ans);
	} // Element()

	// return largest value v where v < a and Choose(v,b) <= x

	public Combination(long n, long k) throws Exception {
		if (n < 0 || k < 0) // normally n >= k
			throw new Exception("Negative parameter in constructor");

		this.n = n;
		this.k = k;
		this.data = new long[(int) k];
		for (int i = 0; i < k; ++i)
			this.data[i] = i;
	} // Combination(n,k)

	public Combination(long n, long k, long[] a) throws Exception // Combination
	// from
	// a[]
	{
		if (k != a.length)
			throw new Exception("Array length does not equal k");

		this.n = n;
		this.k = k;
		this.data = new long[(int) k];
		for (int i = 0; i < a.length; ++i)
			this.data[i] = a[i];

		if (!this.IsValid())
			throw new Exception("Bad value from array");
	} // Combination(n,k,a)

	public boolean IsValid() {
		if (this.data.length != this.k)
			return false; // corrupted

		for (int i = 0; i < this.k; ++i) {
			if (this.data[i] < 0 || this.data[i] > this.n - 1)
				return false; // value out of range

			for (int j = i + 1; j < this.k; ++j)
				if (this.data[i] >= this.data[j])
					return false; // duplicate or not lexicographic
		}

		return true;
	} // IsValid()

	/*
	 * public String toString() { String s = "{ "; for (int i = 0; i < this.k;
	 * ++i) s += this.data[i] + " "; s += "}"; return s; } // ToString()
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer((int) n);
		int kk = 0;
		for (int i = 0; i < n; ++i) {
			if (kk < k && data[kk] == i) {
				sb.append('1');
				++kk;
			} else {
				sb.append('0');
			}
		}
		return sb.toString();
	}

	public String toString(int[] permutation) {
		StringBuffer sb = new StringBuffer((int) n);
		int kk = 0;
		for (int i = 0; i < n; ++i) {
			if (kk < k && data[kk] == i) {
				for (int j = 0; j < permutation[kk]; ++j) {
					sb.append('1');
				}
				++kk;
			} else {
				sb.append('0');
			}
		}
		return sb.toString();
	}

	public BitSet toBitSet(int[] permutation, int size) {
		BitSet bs = new BitSet(size);
		int kk = 0, count = 0;
		for (int i = 0; i < n; ++i) {
			if (kk < k && data[kk] == i) {
				bs.set(count, count + permutation[kk]);
				count += permutation[kk];
				++kk;
			} else {
				++count;
			}
		}
		return bs;
	}

	public long[] getData() {
		return data;
	}

	public Combination Successor() throws Exception {
		if (this.data[0] == this.n - this.k)
			return null;

		Combination ans = new Combination(this.n, this.k);

		int i;
		for (i = 0; i < this.k; ++i)
			ans.data[i] = this.data[i];

		for (i = (int) this.k - 1; i > 0 && ans.data[i] == this.n - this.k + i; --i)
			;

		++ans.data[i];

		for (long j = i; j < this.k - 1; ++j)
			ans.data[(int) j + 1] = ans.data[(int) j] + 1;

		return ans;
	} // Successor()

	public static long choose(long n, long k) throws Exception {
		if (n < 0 || k < 0)
			throw new Exception("Invalid negative parameter in Choose()");
		if (n < k)
			return 0; // special case
		if (n == k)
			return 1;

		long delta, iMax;

		if (k < n - k) // ex: Choose(100,3)
		{
			delta = n - k;
			iMax = k;
		} else // ex: Choose(100,97)
		{
			delta = k;
			iMax = n - k;
		}

		long ans = delta + 1;

		for (long i = 2; i <= iMax; ++i) {
			ans = (ans * (delta + i)) / i;
		}

		return ans;
	} // Choose()

	private static long LargestV(long a, long b, long x) throws Exception {
		long v = a - 1;

		while (choose(v, b) > x)
			--v;

		return v;
	} // LargestV()

}
