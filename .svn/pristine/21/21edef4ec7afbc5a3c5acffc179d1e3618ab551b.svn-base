package clonedetection;

import java.util.LinkedList;
import java.util.List;

import clonedetection.classification.CloneClassification;
import clonedetection.results.CloneResults;
import clonedetection.results.Results;


/**
 * @author bhess
 * 
 * An implementation of the CloneDetector
 */
public class CloneDetectorImpl implements CloneDetector {
	
	/**
	 * Initialized the clone detector with a classifier
	 * @param c
	 * Classifier with which clone classification will be done
	 */
	public CloneDetectorImpl(CloneClassification c) {
		this.classifier = c;
	}
	
	/*
	 * the classifier
	 */
	private CloneClassification classifier;
	
	private CloneDetectionMetrics[][] metrics = null;
	
	
	/*
	 * (non-Javadoc)
	 * @see clonedetection.CloneDetector#analyzeDetection(clonedetection.results.CloneResults[], float)
	 */
	@Override
	public void analyzeDetection(CloneResults[] resultsArr,
			float pmr) {
		
		List<Integer>[] llreal = new List[resultsArr.length];
		int allResultsSize = 0;
		int[] negs = new int[resultsArr.length];
		
		CloneDetectionMetrics[][] res = new CloneDetectionMetrics[resultsArr.length][STEP + 1];
		
		for (int i = 0; i < resultsArr.length; ++i) {
			llreal[i] = resultsArr[i].realClones;
			allResultsSize += resultsArr[i].size();
			negs[i] = resultsArr[i].negs;

		}
		
		//double[] cloneThresholds = new double[results.size()];
		double[] cloneThresholds = new double[allResultsSize];
		
		// creating a list for each tag at which threshold it is considered clone...
		int c = 0;
		for (CloneResults results : resultsArr) {
			for (Results r : results) {
				r.checkResults();
				cloneThresholds[c] = classifier.isClone(pmr, r);
				++c;
			}
		}
		// the minimum and maximum threshold recorded for this classifier
		final double min = classifier.getMinThreshold(), max = classifier.getMaxThreshold();
		final double step = (max - min) / (double)STEP;
		LinkedList<Integer>[] lldets = new LinkedList[STEP + 1];

		// for each tag and each step (from minimal recorded threshold until maximal,
		// see if tag is clone with it. 'lldet' contains the clones for each step
		c = 0;
		for (int i = 0; i < resultsArr.length; ++i) {
			for (int j = 0; j <= STEP; ++j) {
				lldets[j] = new LinkedList<Integer>();
			}
			for (Results r : resultsArr[i]) {
				for (int j = 0; j <= STEP; ++j) {
					if (classifier.isClone(min + ((double)j * step), cloneThresholds[c])) {
					// 	with the current threshold (index i), the tag is counterfeit
						lldets[j].add(r.id);
					}
				}
				++c;
			}
			
			for (int j = 0; j <= STEP; ++j) {
				long cloneButPerfectFit = 0, cloneButPerfectFitWOMisread = 0, 
					cloneButMisread = 0, cloneButBoth = 0, totalClone = 0;
				LinkedList<Integer> lldet = lldets[j];
				// System.out.println("--------------Clone Detection--------------");
				int fn = 0, fp = 0;
				for (int k : llreal[i]) {
					if (lldet.contains(k)) {
						// System.out.println("ID: " + i + " - detected");
					} else {
						// System.out.println("ID: " + i + " - false negative");
						fn++;
						
						Results r = resultsArr[i].getByID(k);
						if (r != null) {
							if (r.clonePerfectFitAndMisread >= 0) {
								cloneButBoth += r.clonePerfectFitAndMisread;
							}
							if (r.cloneMisread >= 0) {
								cloneButMisread += r.cloneMisread;
							}
							if (r.clonePerfectFit >= 0) {
								cloneButPerfectFit += r.clonePerfectFit;
							}
							if (r.clonePerfectFitWithoutMisread >= 0) {
								cloneButPerfectFitWOMisread += r.clonePerfectFitWithoutMisread;
							}
							if (r.cloneTotalLength >= 0) {
								totalClone += r.cloneTotalLength;
							}
							
						}
						
						// TODO: Split it into due to misread and due to fit
					}
				}
				for (int k : lldet) {
					if (!llreal[i].contains(k)) {
						// System.out.println("ID: " + i + " - false positive");
						fp++;
					}
				}

				int tn = negs[i] - fp;
				int tp = llreal[i].size() - fn;
				CloneDetectionMetrics met = new CloneDetectionMetrics(tp, fp, fn, tn, min + ((double) j * step));
				met.setNegativeMetrics(cloneButPerfectFit, cloneButPerfectFitWOMisread,
						cloneButMisread, cloneButBoth, totalClone);
				res[i][j] = met;
			}
		}

		this.metrics = res;
		
	}

	/* (non-Javadoc)
	 * @see clonedetection.CloneDetector#getMetrics()
	 */
	@Override
	public CloneDetectionMetrics[][] getMetrics() {
		return metrics;
	}
	
	/*
	public NegativesMetrics getNegativeMetrics() {
		return new NegativesMetrics(cloneButPerfectFit, cloneButPerfectFitWOMisread,
				cloneButMisread, cloneButBoth, totalClone);
	}
	*/
	
}
