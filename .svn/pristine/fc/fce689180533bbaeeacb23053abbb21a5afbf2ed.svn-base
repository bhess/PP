package simulation;

import java.sql.Connection;
import java.sql.ResultSet;
import java.util.LinkedList;

import clonedetection.results.CloneResults;
import clonedetection.results.Results;

import simulation.utilities.DBConnection;
import simulation.utilities.Logging;

/**
 * @author bhess
 * 
 * Class to analyze the traces from the Database
 * Produces an object of type CloneResults from it
 */
public class TracesAnalyzer {
	
	/**
	 * Query to list all traces (id,step(in/out),location) ordered by id and time
	 */
	private String SQL_TRACES = "select id,step,location,clone,misread from records order by id,time";
	
	/**
	 * Query to list all id's of cloned tags 
	 */
	private String SQL_CLONES = "select id from records where clone=1 group by id";
	
	/**
	 * Query to output the number of original tags (genuine)
	 */
	private String SQL_ORIGINALS = "select count(*) from (select distinct id from records where clone=0) as t";
	
	/**
	 * Initialize the trace analyzer with the table name of the corresponding DB
	 * and the thread the Analyzer should run on
	 * @param tableName
	 * DB table name with the traces of a simulation
	 * @param thread
	 * Thread number where the analysis should run on
	 */
	public TracesAnalyzer(String tableName, int thread) {
		SQL_TRACES = SQL_TRACES.replace("records", tableName);
		SQL_CLONES = SQL_CLONES.replace("records", tableName);
		SQL_ORIGINALS = SQL_ORIGINALS.replace("records", tableName);
		this.conn = DBConnection.getConnection(thread);
	}
	
	/**
	 * DB Connection
	 */
	private Connection conn;
	
	/**
	 * The Clone results
	 */
	private CloneResults cloneResults = null;
	
	/**
	 * List of tag ID's of the real clones
	 */
	LinkedList<Integer> llreal = new LinkedList<Integer>();
	
	/**
	 * The number of negatives (original tags)
	 */
	private int negs = 0;
	
	/**
	 * outputs the CloneResults from the given Database
	 * @return
	 */
	public CloneResults getResults() {
		if (cloneResults == null) {
			analyze();
			try {
				ResultSet rs = conn.createStatement().executeQuery(SQL_CLONES);
				while (rs.next()) {
					llreal.add(rs.getInt(1));
				}
				rs = conn.createStatement().executeQuery(SQL_ORIGINALS);
				rs.next();
				negs = rs.getInt(1);
			} catch (Exception e) {
				Logging.log.fatal(e.getMessage());
				System.exit(1);
			}
		}
		cloneResults.realClones = llreal;
		cloneResults.negs = negs;
		return cloneResults;
	}
	
	/** 
	 * Analyzes the DB given by the Constructor
	 * and outputs the result in 'cloneResults'
	 */
	private void analyze() {
		try {
			cloneResults = new CloneResults();
			ResultSet rs = conn.createStatement().executeQuery(SQL_TRACES);
			LinkedList<String> traceList = new LinkedList<String>(), 
				locList = new LinkedList<String>();
			LinkedList<Boolean> misreadList = new LinkedList<Boolean>(),
				cloneList = new LinkedList<Boolean>();
			int cid = -1;
			boolean isClone = false;
			while (rs.next()) {
				int id = rs.getInt(1);
				String step = rs.getString(2);
				String location = rs.getString(3);
				boolean currentIsClone = rs.getBoolean(4);
				boolean misr = rs.getBoolean(5);
				
				if (cid == -1) cid = id;
				
				// new id is the one of a next trace -> check rules
				if (cid != id && cid != -1) {
					/*
					Results tmpres = new Results(cid, traceList.size());
					tmpres.putTraceList(traceList);
					tmpres.putLocations(locList);
					*/
					//Results tmpres = new Results(cid, traceList.size() - 1);
					//checkRules(traceList.toArray(new String[traceList.size()]), 
					//		locList.toArray(new String[locList.size()]), tmpres);
					Results tmpres = makeResult(locList, traceList, misreadList,
							cloneList, cid, isClone);
					// in rare cases, trace length is 0, so don't add them
					if (tmpres != null) {
						cloneResults.put(cid, tmpres);
					}// else System.out.println(cid);
					traceList = new LinkedList<String>();
					locList = new LinkedList<String>();
					misreadList = new LinkedList<Boolean>();
					cloneList = new LinkedList<Boolean>();
					isClone = false;
					cid = id;
				}
				traceList.add(step);
				locList.add(location);
				cloneList.add(currentIsClone);
				misreadList.add(misr);
				isClone = currentIsClone ? true : isClone;
			}
			if (!traceList.isEmpty()) {
				Results tmpres = makeResult(locList, traceList, misreadList,
						cloneList, cid, isClone);
				if (tmpres != null) {
					cloneResults.put(cid, tmpres);
				}// else System.out.println("Last: " + cid);
				
				/*
				Results tmpres = new Results(cid, traceList.size());
				tmpres.putTraceList(traceList);
				tmpres.putLocations(locList);
				//Results tmpres = new Results(cid, traceList.size() - 1);
				//checkRules(traceList.toArray(new String[traceList.size()]), 
				//		locList.toArray(new String[locList.size()]), tmpres);
				cloneResults.put(cid, makeResult(locList, traceList, misreadList,
						cloneList, cid, isClone));
				*/
			}
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
	
	private Results makeResult(LinkedList<String> loc, LinkedList<String> step,
			LinkedList<Boolean> misr, LinkedList<Boolean> clone, int id, boolean isClone) {
		boolean allMisr = true;
		for (boolean m : misr) {
			if (!m) {
				allMisr = false;
				break;
			}
		}
		if (allMisr) return null;
		Results res;
		if (!isClone) {
			String[] locA = loc.toArray(new String[loc.size()]), stepA = step
				.toArray(new String[step.size()]);
			Boolean[] misrA = misr.toArray(new Boolean[misr.size()]);
			LinkedList<String> locV = new LinkedList<String>(), stepV = new LinkedList<String>();
			int size = 0;
			for (int i = 0; i < locA.length; ++i) {
				if (!misrA[i]) {
					locV.add(locA[i]);
					stepV.add(stepA[i]);
					++size;
				}
			}
			res = new Results(id, size);
			res.putLocations(locV);
			res.putTraceList(stepV);
		} else {
			String[] locA = loc.toArray(new String[loc.size()]), stepA = step
					.toArray(new String[step.size()]);
			Boolean[] misrA = misr.toArray(new Boolean[misr.size()]),
				cloneA = clone.toArray(new Boolean[clone.size()]);
			
			LinkedList<String> locV = new LinkedList<String>(), stepV = new LinkedList<String>();
			LinkedList<Boolean> cloneV = new LinkedList<Boolean>();
			// dueMisr is -1 initially because counterfeiter is counted as misread!
			int duePerfectFit = 0, dueMisr = -1, dueBoth = -1, clonedTotal = 0;
			int viewSize = 0;
			
			int overhang = 0;
			for (int i = 0; i < locA.length; ++i) {
				if (cloneA[i]) {
					if (overhang == 0) {
						int count = 0;
						boolean allclones = true;
						for (int j = i; j < locA.length; ++j) {
							if (cloneA[j]) {
								++count;
							} else {
								allclones = false;
								break;
							}
						}
						if (allclones) {
							overhang = count;
						}
					}
					
					boolean dpf = (i > 0 && cloneA[i-1] && isPerfectFit(locA, stepA, i-1)) ||
						(i < locA.length - 1 && cloneA[i+1] && isPerfectFit(locA, stepA, i));
					boolean dm = misrA[i];
					boolean both = dpf && dm;
					
					if (dpf) ++duePerfectFit;
					if (dm) ++dueMisr;
					if (both) ++dueBoth;
					++clonedTotal;
				}
				
				if (!misrA[i]) {
					locV.add(locA[i]);
					stepV.add(stepA[i]);
					cloneV.add(cloneA[i]);
					++viewSize;
				}				

			}
			res = new Results(id, viewSize);
			res.overhang = overhang;
			if (clonedTotal > 0) {
				res.clone = true;
				res.cloneMisread = dueMisr;
				res.clonePerfectFit = duePerfectFit;
				res.clonePerfectFitAndMisread = dueBoth;
				res.cloneTotalLength = clonedTotal;
			} else {
				Logging.log.fatal("isClone true but clonedTotal!>0");
				System.exit(1);
			}
			
			
			res.putLocations(locV);
			res.putTraceList(stepV);
			
			locA = locV.toArray(new String[locV.size()]);
			stepA = stepV.toArray(new String[stepV.size()]);
			cloneA = cloneV.toArray(new Boolean[cloneV.size()]);
			int duePerfectFitWithoutMisread = 0;
			for (int i = 0; i < locA.length; ++i) {
				if (cloneA[i]) {
					boolean dpf = (i > 0 && cloneA[i-1] && isPerfectFit(locA, stepA, i-1)) ||
						(i < locA.length - 1 && cloneA[i+1] && isPerfectFit(locA, stepA, i));
					if (dpf) ++duePerfectFitWithoutMisread;
				}
			}
			res.clonePerfectFitWithoutMisread = duePerfectFit;
			
		}
		return res;
	}
	

	/*
	private boolean isPerfectFit(String loc1, String step1, String loc2, String step2,
			String locBefore, String stepBefore, String lovAfter, String stepAfter) {
		return step1.equals("IN") && step2.equals("OUT") && loc1.equals(loc2);
	}*/
	
	/**
	 * Perfect fit means
	 *            [i-1]  [i]   [i+1]  [i+2]
	 * Clone:    --------IN_C--OUT_C-------
	 * Original: -OUT_A---------------IN_B-
	 * @param loc1
	 * @param step1
	 * @param loc2
	 * @param step2
	 * @return
	 */
	private boolean isPerfectFit(String[] loc, String[] step, int i) {
		boolean res = step[i].equals("IN") && step[i+1].equals("OUT") && loc[i].equals(loc[i+1]);
		if (!res) return false;
		if (i - 1 >= 0) {
			res &= step[i-1].equals("OUT") && !loc[i-1].equals(loc[i]); 
		}
		if (i + 2 < loc.length) {
			res &= step[i+2].equals("IN") && !loc[i+1].equals(loc[i+2]);
		}
		return res;
	}

}
