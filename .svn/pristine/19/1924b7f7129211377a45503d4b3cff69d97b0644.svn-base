package evaluation;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.LinkedList;

import simulation.utilities.DBConnection;
import simulation.utilities.Logging;

/**
 * Class for analyzing the output of a simulation
 * from its Database
 * 
 * @author bhess
 *
 */
public class OutputAnalysis {

	/*
	 * Query for creating a View with each location and its Misread probability
	 * Pmr
	 */
	private String VIEWMISR = "create view eval.recordsmisr (location, pmr) as select l1,double(c1)/double(c2) as pmr from (select location as l1, count(*) as c1 from records where misread=1 group by location) as t1 inner join (select location as l2, count(*) as c2 from records group by location) as t2 on t1.l1=t2.l2";

	/*
	 * Query for creating a View with each location and its Reused ID rate
	 * RID
	 */
	private String VIEWRID = "create view eval.recordsreuseid (location, rid) as select l1,double(c1)/double(c2) as pmr from (select location as l1, count(*) as c1 from records where clone=1 group by location) as t1 inner join (select location as l2, count(*) as c2 from records group by location) as t2 on t1.l1=t2.l2";
	
	/*
	 * Query for creating a View with each location and its Eavesdropping rate EID
	 * (how many flowing tags are eavesdropped)
	 */
	private String VIEWEAVES = "create view eval.recordseaves (location, eaves) as select l1,double(c1)/double(c2) as eaves from (select location as l1, count(*) as c1 from records where eavesdropped=1 group by location) as t1 inner join (select location as l2, count(*) as c2 from records group by location) as t2 on t1.l1=t2.l2";
	
	/*
	 * Query to list Pmr, RID and EID per location
	 * 
	 * Views have to exist in advance!
	 */
	private String PMRRIDEAV = "select dummy.location,eval.recordsmisr.pmr,eval.recordsreuseid.rid,eval.recordseaves.eaves from (select location from records group by location) as dummy left join eval.recordsmisr on dummy.location=eval.recordsmisr.location left join eval.recordseaves on dummy.location=eval.recordseaves.location left join eval.recordsreuseid on dummy.location=eval.recordsreuseid.location";
	
	/*
	 * Query to list the number of visited entities for each tag
	 */
	private String nmbrofvisitedentities = "select id,count(*) from (select id,count(*) as c from records group by id, location) as l group by id";
	
	/*
	 * Query to list the number of events created for each tag
	 */
	private String nmbofvisitedandnmbevents = "select id,count(*) as visited,sum(c) as events from (select id,count(*) as c from records group by id, location) as l group by id";
	
	/*
	 * Query that calculates the average number of visited entities per tag 
	 * and the average numver of events per tag
	 * 
	 * (only one result row)
	 */
	private String AVGS = "select avg(double(visited)),avg(double(events)) from (select id,count(*) as " + 
		"visited,sum(c) as events from (select id,count(*) as c from records group by id, location) as l group by id) as avgs";
	
	/*
	 * Query to list the first occurence time and the last occurence time
	 * for each tag
	 */
	private String minmaxocc = "select id, min(time), max(time) from records where clone=0 group by id";
	
	private String OUT_RATE_MINMAX = "select count(*),min(t1.time),max(t1.time) from (select id,min(time) as time from records group by id) as t1";
	
	/*
	 * Query for listing all locations
	 */
	private String ENTITIES = "select distinct location from records";
	
	/*
	 * Query for listing all IDs, times of recording locations
	 * and step (IN-OUT)
	 */
	private String ALL = "select id,time,location,step from records";
	
	/*
	 * Query to drop the misread view
	 */
	private String DROP_EVAL = "drop view eval.recordsmisr";
	
	/*
	 * Query to drop the RID vies
	 */
	private String DROP_REUSEID = "drop view eval.recordsreuseid";
	
	/*
	 * Query to drop the EID view
	 */
	private String DROP_EAVES = "drop view eval.recordseaves";
	
	/*
	 * DB connection for this Output analysis
	 */
	public Connection conn;
	
	/**
	 * Initialization with tableName and the thread the Analysis runs on
	 * @param tableName
	 * DB table name
	 * @param thread
	 * The thread number it runs on (>NUM_THREADS)
	 */
	public OutputAnalysis(String tableName, int thread) {
		this.conn = DBConnection.getConnection(thread);
		VIEWMISR = VIEWMISR.replace("records", tableName);
		VIEWRID = VIEWRID.replace("records", tableName);
		VIEWEAVES = VIEWEAVES.replace("records", tableName);
		PMRRIDEAV = PMRRIDEAV.replace("records", tableName);
		AVGS = AVGS.replace("records", tableName);
		minmaxocc = minmaxocc.replace("records", tableName);
		ENTITIES = ENTITIES.replace("records", tableName);
		ALL = ALL.replace("records", tableName);
		
		DROP_EVAL = DROP_EVAL.replace("records", tableName);
		DROP_REUSEID = DROP_REUSEID.replace("records", tableName);
		DROP_EAVES = DROP_EAVES.replace("replace", tableName);
		
		nmbrofvisitedentities = nmbrofvisitedentities.replace("records", tableName);
		nmbofvisitedandnmbevents = nmbofvisitedandnmbevents.replace("records", tableName);
		OUT_RATE_MINMAX = OUT_RATE_MINMAX.replace("records", tableName);
		
	}
	
	/**
	 * analyzes the output of the simulation
	 * @param verbose set true if info should be written to the console
	 */
	public void analyzeOutput(boolean verbose) {
		this.verbose = verbose;
		avgTime();
		avgEvents();
		if (verbose) {
			times();
		}
	}
	
	/**
	 * returns the average number of events
	 * a tag has produced in the supply chain
	 */
	public double getAvgEvents() {
		return avgEvents;
	}
	
	/**
	 * returns the average number of visited partners (hops)
	 * a tag has made in the supply chain
	 */
	public double getAvgHops() {
		return avgHops;
	}
	
	/**
	 * gets the average time a tag is in the supply chain
	 * @return time in seconds
	 */
	public double getAvgTimeInChain() {
		return avgTimeInChain;
	}
	
	/**
	 * verbose is set to true when info should be
	 * written to the console
	 */
	private boolean verbose;
	
	/**
	 * nmb. hops and nmb. events per tag
	 */
	private double avgHops, avgEvents;
	
	/**
	 * avg. time in SC
	 */
	private long avgTimeInChain;

	/**
	 * computes the average time a tag is in the supply chain
	 * using the simulation database
	 */
	private void avgTime() {
		try {
			Statement s = conn.createStatement();
			ResultSet rs = s.executeQuery(minmaxocc);
			//System.out.println(count);
			long avg = 0;

			int count = 0;
			while (rs.next()) {
				count++;
			}
			//System.out.println(count);
			rs = s.executeQuery(minmaxocc);
			while (rs.next()) {
				long min = rs.getTimestamp(2).getTime();
				long max = rs.getTimestamp(3).getTime();
				avg += (max - min) / (double)count;
			}
			avg = (long)((double)avg / (double)1000);
			avgTimeInChain = avg;
			if (verbose) {
				System.out.println("avg time in SC: " + avg + "s");
			}
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
	
	/**
	 * computes the average nmbr of hops and the avg nmbr of events
	 */
	private void avgEvents() {
		try {
			Statement s = conn.createStatement();
			ResultSet rs = s.executeQuery(AVGS);
			rs.next();
			
			avgHops = rs.getDouble(1);
			avgEvents = rs.getDouble(2);
			
			
			Logging.log.info("avg # of visited entities: " + avgHops + ", avg # of events " + avgEvents + " (per product)");
			
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
	
	/**
	 * prints the individual data per entity
	 */
	private void times() {
		try {
			Statement s = conn.createStatement();
			ResultSet rs = s.executeQuery(ALL);
			HashMap<String, Entity> hm = createHashMap(rs);
			rs = s.executeQuery(ALL);
			fillHashmap(hm, rs);
			dataPerLocation(hm);
			rs = s.executeQuery(ENTITIES);
			while(rs.next()) {
				String ent = rs.getString(1);
				Entity e = hm.get(ent);
				if (e != null) {
					Logging.log.info("Location " + ent + ": Pmr=" + e.pmr + ", RID=" + e.rid + ", EID=" + e.eid + ", In-Out+dSI=" + (long)e.iolt + "s");
					//System.out.println(ent + ": In-Out + dSI=" + e.iolt);
					for (Partner p : e.partnerList) {
						Logging.log.info("---OILT to " + p.name + ": " + (long)p.oilt + "s, load: " + (double)p.in / (double)e.totalSent);
					}
				} else {
					Logging.log.info(ent + " should be retailer...");
				}
				Logging.log.info("\n");
			}
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
	
	/**
	 * fills the given hashmap with individual data per entity
	 * @param hm
	 */
	private void dataPerLocation(HashMap<String, Entity> hm) {
		try {
			delete();
			Statement s = conn.createStatement();
			s.execute(VIEWEAVES);
			s.execute(VIEWMISR);
			s.execute(VIEWRID);
			ResultSet rs = s.executeQuery(PMRRIDEAV);
			while (rs.next()) {
				String loc = rs.getString(1);
				//double pmr = rs.getDouble(2);
				//double rid = rs.getDouble(3);
				//double eaves = rs.getDouble(4);
				Entity e;
				if (hm.containsKey(loc)) {
					e = hm.get(loc);
				} else {
					e = new Entity();
					hm.put(loc, e);
				}
				e.pmr = rs.getDouble(2);
				e.rid = rs.getDouble(3);
				e.eid = rs.getDouble(4);
				// System.out.println("Location " + loc + ": Pmr=" + pmr + ", RID=" + rid + ", EID=" + eaves);
			}
			rs.close();
			delete();
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
	
	/**
	 * deletes possibly existing temporary views in the database
	 */
	private void delete() {
		try {
			Statement s = conn.createStatement();
			s.execute(DROP_EVAL);
			s.execute(DROP_REUSEID);
			s.execute(DROP_EAVES);
		} catch (Exception e) {
		}
	}
	
	/**
	 * creates a datastructure with all the entities and their
	 * relationships
	 * @param rs result-set with all records
	 * @return entity-relationship, indexed by their name as String	
	 * @throws SQLException
	 */
	private HashMap<String, Entity> createHashMap(ResultSet rs) throws SQLException {
		HashMap<String, Entity> hm  = new HashMap<String, Entity>();
		
		String outLocation, inLocation;
		while(rs.next()) {
			outLocation = rs.getString(3);
			if (!(rs.getString(4).equals("OUT"))) System.err.println("not OUT!");
			rs.next();
			inLocation = rs.getString(3);
			if (!(rs.getString(4).equals("IN"))) System.err.println("not IN!");
			
			Entity loc;
			if (hm.containsKey(outLocation)) {
				loc = hm.get(outLocation);
			} else {
				loc = new OutputAnalysis.Entity();
				hm.put(outLocation, loc);
			}
			loc.incSendProd(inLocation);
		}
		
		
		return hm;
	}
	
	/**
	 * fills the given hashmap with data
	 * @param hm
	 * @param rs data about times...
	 * @throws SQLException
	 */
	private void fillHashmap(HashMap<String, Entity> hm, ResultSet rs) throws SQLException {
		long outTime = -1, inTime = -1;
		String outLocation = "", inLocation = "";
		int cid = -1;
		while(rs.next()) {

			
			outTime = rs.getTimestamp(2).getTime();
			outLocation = rs.getString(3);
			
			int newid = rs.getInt(1);
			if (newid == cid && hm.containsKey(inLocation)) {
				if (outTime == -1 || inTime == -1 || inLocation.equals("") || outLocation.equals(""))
					System.err.println("not initialized!");
				hm.get(inLocation).addIolt((outTime - inTime) / 1000);
			}
			cid = newid;
			
			if (!(rs.getString(4).equals("OUT"))) System.err.println("not OUT!");
			rs.next();
			inTime = rs.getTimestamp(2).getTime();
			inLocation = rs.getString(3);
			if (!(rs.getString(4).equals("IN"))) System.err.println("not IN!");
			hm.get(outLocation).addOilt(inLocation, (inTime - outTime) / 1000);
		}
	}
	
	/**
	 * class for representing a partner in a supply chain
	 * inclusice misread, rid, eid...
	 *
	 */
	public static class Entity {
		Partner getPartner(String p) {
			if (partnerMap.containsKey(p)) {
				return partnerMap.get(p);
			} else {
				Partner np = new Partner(p);
				partnerMap.put(p, np);
				partnerList.add(np);
				return np;
			}
		}
		void incSendProd(String partner) {
			//if (!partnerMap.containsKey(partner)) System.err.println(partner);
			getPartner(partner).in++;
			totalSent++;
		}
		void addOilt(String partner, long time) {
			Partner p = partnerMap.get(partner);
			p.oilt += (double)time / (double)p.in;
		}
		void addIolt(long time) {
			iolt += (double)time / (double)totalSent;
		}
		HashMap<String, Partner> partnerMap = new HashMap<String, Partner>();
		LinkedList<Partner> partnerList = new LinkedList<Partner>();
		double iolt = 0;
		long totalSent = 0;
		
		double pmr, rid, eid;
		
	}
	
	/**
	 * represents a partner of an entity
	 *
	 */
	public static class Partner {
		Partner(String name) {
			this.name = name;
		}
		String name;
		long in = 0;
		 
		double oilt;
	}
}
