package simulation.data;

import java.io.File;
import java.io.IOException;
import java.sql.Time;
import java.util.Calendar;
import java.util.HashMap;

import javax.xml.parsers.*;
import javax.xml.xpath.*;

import org.w3c.dom.*;
import org.xml.sax.*;

import simulation.entities.DirectedChannel;
import simulation.entities.Recipient;
import simulation.entities.Wholesaler;
import simulation.entities.Distributor;
import simulation.entities.Manufacturer;
import simulation.entities.Partner;
import simulation.entities.Retailer;
import simulation.utilities.MathTools;

/**
 * @author bhess
 *
 * Using an XML file for the configuration Source
 */
public class ConfigurationDataXML implements ConfigurationSource {

	/**
	 * Initializing with a path to an XML config file
	 * @param path
	 * Path to the XML config file
	 */
	public ConfigurationDataXML(String path) {
		this.path = path;
	}
	
	/**
	 * Global misread probability (-1 if there isn't such)
	 */
	private float globalPmr = -1f;
	private long globalPOS = -1, globalPOSStd = -1;
	
	/* (non-Javadoc)
	 * @see simulation.data.ConfigurationSource#getConfiguration(java.lang.String)
	 * 
	 * Throws exceptions if the XML config is not well structured against the DTD and so on...
	 */
	public Configuration getConfiguration() throws SAXException, IOException, ParserConfigurationException, XPathExpressionException {		
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		// Validating against DTD
		factory.setValidating(true);
		DocumentBuilder builder = factory.newDocumentBuilder();
		builder.setErrorHandler(new MyErrorHandler());
		Document doc = builder.parse(new File(path));
		xpath = XPathFactory.newInstance().newXPath();
		
		Configuration result;
		
		// sets a global valid sd for the Pmr
		float pmrstd = Float.parseFloat((String)xpath.evaluate("//slot[1]/@Pmrstd", doc, XPathConstants.STRING));
		
		// TODO complete with startdate...
		if (xpath.evaluate("//slot[1]/@startdate", doc, XPathConstants.STRING) == "") {
			result = new Configuration();
		} else result = new Configuration();
		
		// if there's a global valid Pmr, set it!
		Object gPmr = xpath.evaluate("//slot[1]/@Pmr", doc, XPathConstants.STRING);
		if (gPmr != null && !((String)gPmr).isEmpty()) {
			globalPmr = Float.parseFloat((String)gPmr);
			result.globalPmr = globalPmr;
		}
		Node tmpn = (Node)xpath.evaluate("//slot[1]", doc, XPathConstants.NODE);
		long gpos = getPOS(tmpn);
		if (gpos != 0) {
			globalPOS = gpos;
			globalPOSStd = getPOSStd(tmpn, "POS");
		}
		
		int mcount = Integer.parseInt((String)xpath.evaluate("count(//manufacturer)", doc, XPathConstants.STRING));
		int wcount = Integer.parseInt((String)xpath.evaluate("count(//wholesaler)", doc, XPathConstants.STRING));
		int rcount = Integer.parseInt((String)xpath.evaluate("count(//retailer)", doc, XPathConstants.STRING));
		partnerMap = new HashMap<String, Partner>(mcount + wcount + rcount);
		
		NodeList n = (NodeList)xpath.evaluate("//manufacturer/@name", doc, XPathConstants.NODESET);
		for (int i = 0; i < mcount; i++) {
			String name = n.item(i).getNodeValue();
			Manufacturer m = new Manufacturer();
			partnerMap.put(name, m);
			result.manufacturers.add(m);
			result.partners.add(m);
		}

		n = (NodeList)xpath.evaluate("//wholesaler/@name", doc, XPathConstants.NODESET);		
		for (int i = 0; i < wcount; i++) {
			String name = n.item(i).getNodeValue();
			Wholesaler d = new Wholesaler();
			partnerMap.put(name, d);
			result.partners.add(d);
		}
		
		n = (NodeList)xpath.evaluate("//retailer/@name", doc, XPathConstants.NODESET);
		for (int i = 0; i < rcount; i++) {
			String name = n.item(i).getNodeValue();
			Retailer r = new Retailer();
			partnerMap.put(name, r);
			result.partners.add(r);
		}
		
		long seed = Calendar.getInstance().getTimeInMillis();
		
		// Completing the manufacturers
		n = (NodeList)xpath.evaluate("//manufacturer/mslot[@id=//slot[1]/@id]", doc, XPathConstants.NODESET);
		for (int i = 0; i < mcount; i++) {
			Node mprop = n.item(i);
			String id = (String)xpath.evaluate("../@name", mprop);
			Manufacturer m = (Manufacturer)partnerMap.get(id);
			float pmr = getPmr(mprop, pmrstd);
			result.globalPmr = pmr;
			m.init(id, getNmbrChannels(mprop), seed++, pmr, 
					getPr(mprop), result.startDate, getPt(mprop), getRID(mprop));
			addShippingInstants(m, (NodeList)xpath.evaluate("./Si/time", mprop, XPathConstants.NODESET));
			addPartners(m, (NodeList)xpath.evaluate("./partner", mprop, XPathConstants.NODESET));
		}
		
		// Completing the wholesalers
		n = (NodeList)xpath.evaluate("//wholesaler/wslot[@id=//slot[1]/@id]", doc, XPathConstants.NODESET);
		for (int i = 0; i < wcount; i++) {
			Node mprop = n.item(i);
			String id = (String)xpath.evaluate("../@name", mprop);
			Wholesaler w = (Wholesaler)partnerMap.get(id);
			float pmr = getPmr(mprop, pmrstd);
			result.globalPmr = pmr;
			w.init(id, getNmbrChannels(mprop), seed++, pmr, getIOLT(mprop), getStd(mprop, "IOLT"));
			addShippingInstants(w, (NodeList)xpath.evaluate("./Si/time", mprop, XPathConstants.NODESET));
			addPartners(w, (NodeList)xpath.evaluate("./partner", mprop, XPathConstants.NODESET));
		}
		
		// Completing the retailers
		n = (NodeList)xpath.evaluate("//retailer/rslot[@id=//slot[1]/@id]", doc, XPathConstants.NODESET);
		for (int i = 0; i < rcount; i++) {
			Node mprop = n.item(i);
			String id = (String)xpath.evaluate("../@name", mprop);
			Retailer r = (Retailer)partnerMap.get(id);
			float pmr = getPmr(mprop, pmrstd);
			result.globalPmr = pmr;
			long pos = getPOS(mprop);
			long posstd = (pos == 0 ? 0 : getPOSStd(mprop, "POS"));
			r.init(id, seed++, pmr, (globalPOS == -1 ? pos : globalPOS), (globalPOSStd == -1 ? posstd : globalPOSStd));
		}
		
		//System.out.println((String)xpath.evaluate("", n, XPathConstants.STRING));
		if (!consistencyCheck(result)) {
			throw new IOException("Consistency check failed");
		}
		return result;
	}
	
	/**
	 * Stub to check consistency of the configuration .. TODO: implement...
	 * @param c
	 * @return
	 */
	private boolean consistencyCheck(Configuration c) {
		return true;
	}
	
	/**
	 * gets Pmr for a node
	 * @param n
	 * Node
	 * @param std
	 * Standard deviation
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private float getPmr(Node n, float std) throws NumberFormatException, XPathExpressionException {
		// if there's a global Pmr, take this, otherwise take individual one!
		float pmr = (globalPmr == -1f ? Float.parseFloat((String)xpath.evaluate("@Pmr", n, 
				XPathConstants.STRING)) : globalPmr);
		float res = (float)MathTools.nextGaussian(pmr, std);
		if (res > 1.0f) res = 1.0f;
		else if (res < 0.0f) res = 0.0f;
		return res;
	}
	
	/**
	 * Gets Pr for a node
	 * @param n
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private int getPr(Node n) throws NumberFormatException, XPathExpressionException {
		return Integer.parseInt((String)xpath.evaluate("@Pr", n, XPathConstants.STRING)); 
	}
	
	/**
	 * Gets Production time for a node
	 * @param n
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private long getPt(Node n) throws NumberFormatException, XPathExpressionException {
		return getTime((Node)xpath.evaluate("./Pt", n, XPathConstants.NODE));
	}
	
	/**
	 * Gets RID for a node
	 * @param n
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private float getRID(Node n) throws NumberFormatException, XPathExpressionException {
		return Float.parseFloat((String)xpath.evaluate("@RID", n, XPathConstants.STRING));
	}
	
	/**
	 * gets EID at source of a channel
	 * @param n
	 * Using XML node n
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private float getEIDsource(Node n) throws NumberFormatException, XPathExpressionException {
		return Float.parseFloat((String)xpath.evaluate("./EID/@source", n, XPathConstants.STRING));
	}
	
	/**
	 * gets EID offset at source of channel
	 * @param n
	 * XML node
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private long getEIDsrcoff(Node n) throws NumberFormatException, XPathExpressionException {
		return Long.parseLong((String)xpath.evaluate("./EID/@srcOffset", n, XPathConstants.STRING));
	}
	
	/**
	 * gets EID at destination of channel
	 * @param n
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private float getEIDdestination(Node n) throws NumberFormatException, XPathExpressionException {
		return Float.parseFloat((String)xpath.evaluate("./EID/@destination", n, XPathConstants.STRING));
	}
	
	/**
	 * gets EID offset at destination of channel
	 * @param n
	 * XML node n
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private long getEIDdstoff(Node n) throws NumberFormatException, XPathExpressionException {
		return Long.parseLong((String)xpath.evaluate("./EID/@dstOffset", n, XPathConstants.STRING));
	}
	
	/**
	 * gets number of channels
	 * @param n
	 * Used XML node
	 * @return
	 * @throws NumberFormatException
	 * @throws XPathExpressionException
	 */
	private int getNmbrChannels(Node n) throws NumberFormatException, XPathExpressionException {
		return Integer.parseInt((String)xpath.evaluate("count(./partner)", n, XPathConstants.STRING)); 
	}
	
	/**
	 * gets In-Out lead time
	 * @param n
	 * Used XML-Node
	 * @return
	 * @throws XPathExpressionException
	 */
	private long getIOLT(Node n) throws XPathExpressionException {
		return getTime((Node)xpath.evaluate("./IOLT", n, XPathConstants.NODE));
	}
	
	/**
	 * gets Standard deviation
	 * @param n
	 * Used XML-Node
	 * @param parent
	 * Parent path
	 * @return
	 * @throws XPathExpressionException
	 */
	private long getStd(Node n, String parent) throws XPathExpressionException {
		return getTime((Node)xpath.evaluate("./" + parent + "/std", n, XPathConstants.NODE));
	}
	
	/**
	 * gets POS lead time
	 * @param n
	 * Used XML-Node
	 * @return
	 * @throws XPathExpressionException
	 */
	private long getPOS(Node n) throws XPathExpressionException {
		Object obj = xpath.evaluate("./POS", n, XPathConstants.NODE);
		return (obj == null ? 0 : getTime((Node)obj));
	}
	
	/**
	 * gets Standard deviation
	 * @param n
	 * Used XML-Node
	 * @param parent
	 * Parent path
	 * @return
	 * @throws XPathExpressionException
	 */
	private long getPOSStd(Node n, String parent) throws XPathExpressionException {
		return getTime((Node)xpath.evaluate("./" + parent + "/std", n, XPathConstants.NODE));
	}
	
	/**
	 * Adds Shipping instants
	 * @param d
	 * Distributor to which instants will be added
	 * @param nl
	 * XML-NodeList where instants are taken from 
	 */
	private void addShippingInstants(Distributor d, NodeList nl) {
		for (int i = 0; i < nl.getLength(); i++) {
			NamedNodeMap nnm = nl.item(i).getAttributes();
			int hours = (nnm.getNamedItem("hour") == null ? 0 : Integer.parseInt(nnm.getNamedItem("hour").getNodeValue()));
			int mins = (nnm.getNamedItem("min") == null ? 0 : Integer.parseInt(nnm.getNamedItem("mins").getNodeValue()));
			int secs = (nnm.getNamedItem("sec") == null ? 0 : Integer.parseInt(nnm.getNamedItem("secs").getNodeValue()));
			d.addShippingInstant(new Time(hours, mins, secs));
		}
	}
	
	/**
	 * Adding partners to a distributor
	 * @param d
	 * Distributor to which partners will be added to
	 * @param nl
	 * XML-NodeSet where the partners are taken from
	 * @throws XPathExpressionException
	 */
	private void addPartners(Distributor d, NodeList nl) throws XPathExpressionException {
		for (int i = 0; i < nl.getLength(); i++) {
			Node n = nl.item(i);
			Node oilt = (Node)xpath.evaluate("./OILT", n, XPathConstants.NODE);
			NamedNodeMap nnm = n.getAttributes();
			String id = nnm.getNamedItem("id").getNodeValue();
			float load = Float.parseFloat(nnm.getNamedItem("OL").getNodeValue());
			d.addChannel(new DirectedChannel(d, (Recipient)partnerMap.get(id), load, getTime(oilt),
					getStd(n, "OILT"),getEIDsource(n), getEIDdestination(n), getEIDsrcoff(n), getEIDdstoff(n)));
		}
	}
	
	/**
	 * Gets time from an XML-Node
	 * @param n
	 * XML-Node where time is taken from
	 * @return
	 * Time in Seconds
	 */
	private long getTime(Node n) {
		NamedNodeMap nnm = n.getAttributes();
		int years = (nnm.getNamedItem("years") == null ? 0 : Integer.parseInt(nnm.getNamedItem("years").getNodeValue()));
		int months = (nnm.getNamedItem("months") == null ? 0 : Integer.parseInt(nnm.getNamedItem("months").getNodeValue()));
		int days = (nnm.getNamedItem("days") == null ? 0 : Integer.parseInt(nnm.getNamedItem("days").getNodeValue()));
		int hours = (nnm.getNamedItem("hours") == null ? 0 : Integer.parseInt(nnm.getNamedItem("hours").getNodeValue()));
		int mins = (nnm.getNamedItem("mins") == null ? 0 : Integer.parseInt(nnm.getNamedItem("mins").getNodeValue()));
		int secs = (nnm.getNamedItem("secs") == null ? 0 : Integer.parseInt(nnm.getNamedItem("secs").getNodeValue()));
		
		long res = secs + mins*60 + hours*60*60 + days*24*60*60 + months*30*24*60*60 + years*365*24*60*60;
		return res;
	}
	
	/**
	 * XPath object
	 */
	private XPath xpath;
	
	/**
	 * HashMap with Partners indexed by their names
	 */
	private HashMap<String, Partner> partnerMap;
	
	/**
	 * Path of XML-File
	 */
	private String path;
	
	private class MyErrorHandler implements ErrorHandler {
		  public void warning(SAXParseException e) throws SAXException {
		    show("Warning", e);
		    throw (e);
		  }

		  public void error(SAXParseException e) throws SAXException {
		    show("Error", e);
		    throw (e);
		  }

		  public void fatalError(SAXParseException e) throws SAXException {
		    show("Fatal Error", e);
		    throw (e);
		  }

		  private void show(String type, SAXParseException e) {
		    System.err.println(type + ": " + e.getMessage());
		    System.err.println("Line " + e.getLineNumber() + " Column "
		        + e.getColumnNumber());
		    System.err.println("System ID: " + e.getSystemId());
		  }
	}

}
