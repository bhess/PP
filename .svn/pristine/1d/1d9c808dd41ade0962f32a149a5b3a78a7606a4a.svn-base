package simulation.utilities;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

/**
 * @author bhess
 * 
 * Class representing Database Connections
 * Now uses connection to the Apache Derby Database
 *
 */
public class DBConnection {
	
	/**
	 * The Derby URL
	 */
	public static String dbURL = "jdbc:derby:myDB;create=true";
	
	/**
	 * Setting the Derby DB location
	 * @param path
	 * path to the DB location, if it doesn't exist yet,
	 * it will be newly created
	 */
	public static void setDBLocation(String path) {
		dbURL = dbURL.replace("myDB", path);
	}

	/**
	 * Sets the number of threads for connections
	 * so then individual connections for each thread will
	 * be created
	 * @param threads
	 * number of threads
	 */
	public static void setThreads(int threads) {
		if (conns != null) return;
		conns = new Connection[threads];
		try {
			for (int i = 0; i < conns.length; ++i) {
				Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
				conns[i] = DriverManager.getConnection(dbURL);
			}
		} catch (Exception e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
	
	/**
	 * gets a DB connection for the tread
	 * @param thread
	 * Thread for which a connection should be returned
	 * @return
	 * A DB connection
	 */
	public static synchronized Connection getConnection(int thread) {
		if (conns[thread] != null) {
			return conns[thread];
		} else {
			try {
				Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
				conns[thread] = DriverManager.getConnection(dbURL);
				return conns[thread];
			} catch (Exception e) {
				Logging.log.fatal(e.getMessage());
				System.exit(1);
			}
			return null;
		}
	}
	
	/**
	 * Returns a DB connection
	 * Non-threadsage variant
	 * @return
	 */
	public static synchronized Connection getConnection() {
		if (conn != null) {
			return conn;
		} else {
			try {
				Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
				conn = DriverManager.getConnection(dbURL);
				return conn;
			} catch (Exception e) {
				Logging.log.fatal(e.getMessage());
				System.exit(1);
			}
			return null;
		}
	}
	
	/**
	 * Executes a thread critical update
	 * @param sql
	 * @throws SQLException
	 */
	public static synchronized void executeCriticalUpdate(String sql) throws SQLException {
		getConnection().createStatement().executeUpdate(sql);
	}
	
	/**
	 * the connections (one for each thread)
	 */
	private static Connection[] conns;
	
	/**
	 * one connection (not thread-safe)
	 */
	private static Connection conn = null;
	
	/**
	 * closing all connections
	 */
	public static void close() {
		try {
			conn.close();
			for (Connection c : conns) {
				c.close();
			}
		} catch (SQLException e) {
			Logging.log.fatal(e.getMessage());
			System.exit(1);
		}
	}
}
