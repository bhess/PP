package simulation.utilities;

import java.util.HashMap;

import simulation.data.Configuration;
import simulation.entities.DirectedChannel;
import simulation.entities.Distributor;
import simulation.entities.Manufacturer;
import simulation.entities.Recipient;
import simulation.entities.Retailer;

/**
 * @author bhess
 * 
 * Class with graph functions that can be applied on
 * simulation configuration graph
 */
public class GraphUtilities {
	
	/**
	 * Initializing with a given configurations
	 * @param c
	 * The configuration for the graph operations
	 */
	public GraphUtilities(Configuration c) {
		this.config = c;
		this.totalProduction = 0;
		for (Manufacturer m : config.manufacturers) {
			if (m.reuseID != 1.0f) {
				totalProduction += getPrpersec(m.productionRate) * (double)m.productionTime;
			}
		}
	}
	
	private Configuration config;
	
	/**
	 * gets the average time in the supplychain
	 * @param maxcycles
	 * if the graph contains cycles, maxcycles defines how many
	 *  times one cycle should be followed
	 * @return
	 * the average time in the SC in seconds
	 */
	public long getAvgTimeInChain(int maxcycles) {
		this.maxcycles = maxcycles;
		long result = 0;
		HashMap<Recipient, Integer> hm = new HashMap<Recipient, Integer>(config.partners.size());
		for (Manufacturer m : config.manufacturers) {
			if (m.reuseID != 1.0f) {
				initCycles(hm);
				long production = (long)(getPrpersec(m.productionRate) * (double)m.productionTime);
				long atf = avgTimeFrom(m, hm);
				result += ((double)production / (double)totalProduction) * atf;
			}
		}
		return result;
	}
	
	private int maxcycles;
	
	/**
	 * Recursive function to compute avg time from a recipient
	 * @param r
	 * Recipient
	 * @param hm
	 * Hash-map with partners for the recipient
	 *  null if the recipient is a retailer
	 * @return
	 * the average time from this entity
	 */
	private long avgTimeFrom(Recipient r, HashMap<Recipient, Integer> hm) {
		if (r instanceof Retailer) {
			return 0;
		} else {
			// node already visited -> return
			int cy = hm.get(r).intValue();
			if (cy > maxcycles) return 0;
			hm.put(r, new Integer(cy + 1));
			
			Distributor dis = (Distributor)r;
			int sum = 0;
			for (DirectedChannel d : dis.outChannels) {	
				long delay = getDelay(d);
				long avgtfrom = avgTimeFrom(d.desitination, (HashMap)hm.clone());
				if (avgtfrom < 0) Logging.log.info(avgtfrom);
				sum += d.load * ((double)delay + (double)avgtfrom);
			}
			return sum;
		}
	}
	
	/**
	 * gets average delay over the channel
	 * @param d
	 * Channel to compute the delay
	 * @return
	 * delay in seconds
	 */
	private long getDelay(DirectedChannel d) {
		long delay = d.oilt;
		// only if destination is a distributor, add its delays
		if (d.desitination instanceof Distributor) {
			Distributor dis = (Distributor)d.desitination;
			delay += dis.iolt + getAvgTimeToNextSI(dis);
			/*
				Calendar now = (Calendar)config.startDate.clone();
				now.add(Calendar.SECOND, alreadyExpired + delay);
				Calendar nsi = (Calendar)now.clone();
				dis.setNextShippingInstant(nsi);
				delay += (nsi.getTimeInMillis() - now.getTimeInMillis()) / 1000;
			*/
		}
		return delay;
	}
	
	/**
	 * Init the cycles map all with 0
	 * @param hm
	 */
	private void initCycles(HashMap<Recipient, Integer> hm) {
		for (Recipient r : config.partners) {
			hm.put(r, 0);
		}
	}
	
	/**
	 * the total production
	 */
	private int totalProduction;
	
	/**
	 * outputs the production per second
	 * @param prperday
	 * the production per day
	 * @return
	 * the production per second
	 */
	private double getPrpersec(int prperday) {
		return (double)prperday / 86400.0d;
	}
	
	/**
	 * gets the average time in seconds to the next shipping
	 * instant
	 * @param d
	 * The distributor with the shipping instants
	 * @return
	 * the avg. time to the next shipping instant in seconds
	 */
	private long getAvgTimeToNextSI(Distributor d) {
		long avg = 0;
		int sicount = d.shippingInstants.size();
		java.sql.Time t1 = d.shippingInstants.get(0), t2 = t1;
		for (int i = 1; i < sicount; ++i) {
			t2 = d.shippingInstants.get(i);
			long diff = t2.getTime() - t1.getTime();
			// weigthed difference
			avg += (diff / 2) * (diff / 3600000);
		}
		long diff = ((d.shippingInstants.get(0).getTime() + 86400000) - t2.getTime());
		long avglast = (diff / 2) * (diff / 3600000);
		return ((avg + avglast) / (1000 * 24));
	}

}
